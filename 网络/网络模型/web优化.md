## 3月25、26日 早上 27日早上
26日悄悄话@我的心上人：看到你幸福的样子，于是幸福着你的幸福

27日悄悄话@我的心上人：美人兮，见之不忘，一日不见兮，思之如狂。


## 五种I/O
IO系统调用分两步：1. 数据从磁盘装载到内核内存空间 2. 数据从内核内存复制到用户内存

参考文档：https://blog.51cto.com/litaotao/1289790

#### 阻塞IO
第一步：进程直接调用内核，然后休眠等待内核处理完成，内核完成数据准备，唤醒进程。（阻塞）
第二步：进程读取数据，数据从内核内存复制到用户内存。（阻塞）
问题：如需要同时读多个IO，可能阻塞在其中一个IO上，其他IO有数据而不能读。多线程、多进程方式系统开销、维护成本高。

#### 非阻塞IO
第一步：进程直接调用内核，内核马上返回（收到请求）同时准备数据，进程收到返回后定时询问内核数据准备好了吗。（非阻塞）
第二步：进程询问到数据准备好了，读取数据。（阻塞）
问题：轮询浪费CPU资源。

#### IO复用(select)
第一步：进程发起select系统调用，然后进程阻塞，select负责内核调用，select返回进程数据准备完成。（阻塞）
第二步：进程读取数据。（阻塞）
问题：select机制fd_set拷贝、轮询比较好资源，时间复杂度O(n)。低并发效率高。

#### 事件驱动IO(epoll)
第一步：进程发起IO系统调用事件，然后继续做其他事，内核调用结束，内核通知进程数据准备好了。（非阻塞）
第二步：进程读取数据。（阻塞）
问题：5中模式中高并发下性能最好。最优。时间复杂度O(1)。高并发效率高。

#### 异步IO
第一步：进程发起IO系统调用（aio_read函数），然后继续做其他事。（非阻塞）
第二步：内核把数据直接复制到进程内存空间，通知进程，进程直接得到返回的数据。（非阻塞）
问题：异步IO逻辑复杂、信号个数有限，高并发不适用。

#### IO复用之select
1. select是系统调用函数，用户进程调用该函数指示内核等待传入的句柄中任何一个或多个可使用或经历指定时间后唤醒用户进程。
2. fd_set: 需要操作的IO句柄集合。select调用时，用户进程传递拷贝给select进程（拷贝开销大）。
3. 轮询fe_set来查看是否有可用IO。有或time out后返回。

参考文档：https://www.jb51.net/article/101057.htm

#### IO复用之epoll
1. epoll将用户关系的文件句柄放到内核事件表中，用户内存到内核内存只需copy一次
2. 使用MMAP

参考文档: https://blog.csdn.net/nanxiaotao/article/details/90612404

#### select和epoll的区别
1. 同步IO：首先他们都是同步IO，都是在IO就绪时，用户进程自己读取数据。
2. select的句柄1024/2048个数受限。epoll无限制。
3. 每次select调用，都要把fd_set从用户态拷贝到内核态。epoll使用MMAP共享一块内存空间。
4. select轮询fd_set,时间复杂度O(n)。epoll是查看队列是否为空，时间复杂度O(1)。
5. 并发高epoll效率高，否则select效率高。

## web的三种工作模式

#### Prefork工作原理
#### Worker工作原理
#### Event工作原理